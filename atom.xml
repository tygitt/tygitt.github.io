<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hello</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-07-10T12:05:28.751Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>tonyge</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>zookeeper总结与hadoop的安装</title>
    <link href="http://yoursite.com/2019/07/01/zookeeper%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2019/07/01/zookeeper总结/</id>
    <published>2019-07-01T13:14:55.000Z</published>
    <updated>2019-07-10T12:05:28.751Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Zookeeper的理解"><a href="#Zookeeper的理解" class="headerlink" title="Zookeeper的理解"></a>Zookeeper的理解</h3><p>​    zookeeper是apache的一个项目，是一个小型的文件协调服务。官方推荐文件存储大小不超过1MB,本质上也是一个小型的文件存储系统。</p><p>​    zookeeper在集群中的配置，通常是奇数台，原因是zookeeper集群之间存在投票选举机制。就是zookeeper集群之间，会选举出一个老大(leader),剩下的都是小弟(follower),另外还有观察者(observer)的角色，不过这个不常用。</p><p><strong>leader：zk集群中的主节点，主要是处理客户端的事务性请求（增删改）create delete set 操作。</strong></p><p><strong>follower：zk集群中的从节点，主要用来处理客户端的非事务型请求（查询），以及转发来自客户端的事务性请求。</strong></p><p>observer：观察者角色，用来处理非事务性请求（查询），转发事务性的请求。该类型节点不参与投票选举机制。</p><p>​    zookeeper在集群中的配置主要有两个地方，一个是zookeeper/conf/zoo.cfg  。 zk的默认配置文件</p><p>修改dataDir的路径.另一个要修改的就是在这个dataDir路径之中添加一个myid文件,标记该zookeeper的id.</p><h4 id="zookeeper中的主从机制与主备机制"><a href="#zookeeper中的主从机制与主备机制" class="headerlink" title="zookeeper中的主从机制与主备机制"></a>zookeeper中的主从机制与主备机制</h4><p>​    zookeeper中的主从机制：zookeeper集群中会存在一个主节点leader，剩余的都是从节点.leader节点进行任务的分配,从节点执行分配的任务.</p><p>​    zookeeper中的主备机制：zookeeper中的主备机制主要针对于集群中的主节点，备用节点主要是为了保证zk集群的24小时高可用，当leader节点宕机之后，备用节点就会转换为leader节点。确保了zk集群的高可用。</p><p><strong>zookeeper集群的基本特性：全局数据的一致性。保证每一台机器的zk中的数据都是一样的。</strong></p><h4 id="zookeeper的shell操作，以及javaAPI的操作"><a href="#zookeeper的shell操作，以及javaAPI的操作" class="headerlink" title="zookeeper的shell操作，以及javaAPI的操作"></a>zookeeper的shell操作，以及javaAPI的操作</h4><p>​    zookeeper中的每一个节点被称为znode，znode既具有文件的特性，也具有文件夹的特性，即该节点下还可以创建子节点。</p><h5 id="常用的zookeeper-shell操作："><a href="#常用的zookeeper-shell操作：" class="headerlink" title="常用的zookeeper shell操作："></a>常用的zookeeper shell操作：</h5><p>​    ls path：查看该路径下所有的znode（节点）</p><p>​    create [-s] [-e] path  [value] ：在指定路径下创建一个节点。</p><p>​                -s 表示创建一个序列化的节点  -e 表示创建一个临时节点，在client断开连接后，该节点会消失</p><p>​    set：修改覆盖节点中的内容</p><p>​    get：获得节点中的内容</p><p>​    delete：删除该节点，如果该节点下有子节点则无法删除</p><p>​    rmr：递归删除，删除该节点和该节点下的所有节点</p><p>​    get path  watch  ： 为该节点添加watch监听，监听该节点的操作。watch只会触发一次。</p><p>​    history：列出命令的历史</p><h5 id="znode节点的属性"><a href="#znode节点的属性" class="headerlink" title="znode节点的属性"></a>znode节点的属性</h5><p>​    通过get命令可以获得该节点的内容和属性。</p><p>​    znode的属性：</p><p>​        dataVersion:数据的版本号，每次对节点进行set操作，该数字会加1，避免了数据更新的顺序问题</p><p>​        cversion:子节点的版本号，子节点有变化就会加1</p><p>​        aclVersion:ACL的版本号</p><p>​        ephemeralOwner:如果该节点是临时节点，则改值表示与该节点绑定的session id 如果不是临时节点，该值为0</p><p>在client与zkServer通信之前，需要建立连接，该链接成为session</p><h5 id="zookeeper的watch机制"><a href="#zookeeper的watch机制" class="headerlink" title="zookeeper的watch机制"></a>zookeeper的watch机制</h5><p>​    zookeeper提供了 <strong>分布式数据发布/订阅</strong> 功能，一个典型的发布/订阅模型。能让多个订阅者同时监听一个发布者，当该发布者的自身状态改变时，会通知所有订阅者。</p><p>​    zookeeper中通过 <strong>watch机制实现这种分布式的通知功能</strong></p><p>​    大致上来说一个监听器Watcher的流程为：<strong>客户端向服务端注册watcher、服务端发生相应事件触发watcher、客户端回调watcher的触发事件的情况</strong></p><p>​    <strong>watch机制是一次性触发的</strong>，即触发之后，就会销毁。</p><p>​    zookeeper使用WatchedEvent对象封装服务端的事件进行传递</p><p>​    WatchedEvent包含三个基本属性：keeperState 通知状态、EventType 事件类型、Path 节点的路径</p><p>​    watcher的事件通知从服务器端发送到客户端是异步的</p><h5 id="zookeeper的javaAPI"><a href="#zookeeper的javaAPI" class="headerlink" title="zookeeper的javaAPI"></a>zookeeper的javaAPI</h5><p>​    这里采用org.apache.curator该框架进行操作。需要导入curator-framework  curator-recipes两个依赖。</p><p>​    javaAPI开发的大致流程：</p><ol><li><p>获得curatorFramework client对象，这里采用curatorFrameworkFactory工厂对象的静态方法，生成curatorFramework 对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CuratorFramework client = CuratorFrameworkFactory.newClient(String StrConnection,RetryPolicy retryPolicy);</span><br></pre></td></tr></table></figure><p>第一个参数，代表要连接的zookeeper服务器地址，第二个参数RetryPolicy表示重试策略是一个接口</p><p>这里使用的该接口的一个实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RetryPolicy retryPolicy = <span class="keyword">new</span> ExponentiaBackoffRetry(<span class="number">1000</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>其中第一参数为，连接失败重连的时间间隔，第二个参数为尝试重连的次数。</p></li><li><p>开启client连接</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client.start();</span><br></pre></td></tr></table></figure></li><li><p>执行相应操作</p><p><strong>增加操作：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client.create().createParentsIfNeeded().withMode(CreateMode.PERSISTENT).forPath(String path  [,<span class="keyword">byte</span>[] value]);</span><br></pre></td></tr></table></figure><p>其中create()表示创建一个节点</p><p>createParentsIfNeeded()表示如果该节点的路径不存在，创建该路径</p><p>withMode(CreateMode)，传入一个CreateMode枚举类型，表示创建什么类型的节点，有四种类型：永久节点、临时节点、永久序列化节点、临时序列化节点。</p><p>forPath()，表示在哪个路径下创建节点，后面有一个可选参数byte[]，表示该节点的数据</p><p><strong>删除操作：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client.delete().forPath(String path);</span><br></pre></td></tr></table></figure><p>删除指定path的节点</p><p><strong>查看操作：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client.get().forPath(String path);</span><br></pre></td></tr></table></figure><p>返回一个byte[] 数组。 获得该路径下节点的数据</p></li><li><p>关闭客户端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client.close();</span><br></pre></td></tr></table></figure><p>释放连接</p></li></ol><p><strong>节点的watch机制</strong></p><ol><li><p>通过curatorFrameworkFactory的静态方法获得一个client</p></li><li><p>client.start();  建立连接</p></li><li><p>添加监听器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">TreeCache treeCache = <span class="keyword">new</span> TreeCache(CuratorFramework client,String path);</span><br><span class="line"><span class="comment">//添加节点的treeCache</span></span><br><span class="line">treeCache.getListenable().addListener(<span class="keyword">new</span> TreeCacheListener()&#123;</span><br><span class="line">    <span class="comment">// 使用new 接口的方法，采用匿名内部类创建一个对象</span></span><br><span class="line">    <span class="comment">// 重写该接口中的childEvent()方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">childEvent</span><span class="params">(CuratorFramework client, TreeCacheEvent event)</span> Throws Exception</span>&#123;</span><br><span class="line">        ChildData data = event.getData(); <span class="comment">// 获得监听到的数据</span></span><br><span class="line">        <span class="comment">//.... 相应的逻辑代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">treeCache.start(); <span class="comment">// 开始监听</span></span><br><span class="line">Thread.sleep(<span class="number">4000000</span>); <span class="comment">//让这个线程处于休眠状态，一致保持监听状态</span></span><br></pre></td></tr></table></figure><p>值得注意的是，使用javaAPI 添加watcher，该watcher可以被重复的触发，并不是触发一次就销毁</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Zookeeper的理解&quot;&gt;&lt;a href=&quot;#Zookeeper的理解&quot; class=&quot;headerlink&quot; title=&quot;Zookeeper的理解&quot;&gt;&lt;/a&gt;Zookeeper的理解&lt;/h3&gt;&lt;p&gt;​    zookeeper是apache的一个项目，是一个
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>hexo + github搭建个人博客</title>
    <link href="http://yoursite.com/2019/06/30/hexo-github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>http://yoursite.com/2019/06/30/hexo-github搭建个人博客/</id>
    <published>2019-06-30T12:51:08.000Z</published>
    <updated>2019-06-30T13:30:43.059Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用hexo-github搭建个人博客"><a href="#使用hexo-github搭建个人博客" class="headerlink" title="使用hexo+github搭建个人博客"></a>使用hexo+github搭建个人博客</h1><p>使用github作为后台服务器，采用hexo进行博客的搭建，非常简单。大致有以下步骤</p><h4 id="1-首先本地要有安装有git，并且安装nodejs-并配置好环境变量"><a href="#1-首先本地要有安装有git，并且安装nodejs-并配置好环境变量" class="headerlink" title="1.首先本地要有安装有git，并且安装nodejs,并配置好环境变量"></a>1.首先本地要有安装有git，并且安装nodejs,并配置好环境变量</h4><h4 id="2-搞一个github账号"><a href="#2-搞一个github账号" class="headerlink" title="2.搞一个github账号"></a>2.搞一个github账号</h4><h4 id="3-在github上创建一个repository，格式为yourGitHubName-github-io"><a href="#3-在github上创建一个repository，格式为yourGitHubName-github-io" class="headerlink" title="3.在github上创建一个repository，格式为yourGitHubName.github.io"></a>3.在github上创建一个repository，格式为yourGitHubName.github.io</h4><h4 id="4-本地生成SSH，并绑定到你的github账号"><a href="#4-本地生成SSH，并绑定到你的github账号" class="headerlink" title="4.本地生成SSH，并绑定到你的github账号"></a>4.本地生成SSH，并绑定到你的github账号</h4><h4 id="5-将hexo部署到github"><a href="#5-将hexo部署到github" class="headerlink" title="5.将hexo部署到github"></a>5.将hexo部署到github</h4><h4 id="6-格式化hexo，发布文章"><a href="#6-格式化hexo，发布文章" class="headerlink" title="6.格式化hexo，发布文章"></a>6.格式化hexo，发布文章</h4><h4 id="7-查看。设置个人域名"><a href="#7-查看。设置个人域名" class="headerlink" title="7.查看。设置个人域名"></a>7.查看。设置个人域名</h4><p><img src="assets/skr.jpeg" alt="skr"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;使用hexo-github搭建个人博客&quot;&gt;&lt;a href=&quot;#使用hexo-github搭建个人博客&quot; class=&quot;headerlink&quot; title=&quot;使用hexo+github搭建个人博客&quot;&gt;&lt;/a&gt;使用hexo+github搭建个人博客&lt;/h1&gt;&lt;p&gt;使用
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2019/06/30/hello-world/"/>
    <id>http://yoursite.com/2019/06/30/hello-world/</id>
    <published>2019-06-30T07:26:57.832Z</published>
    <updated>2019-06-30T07:26:57.833Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
